[{"title":"JS中的闭包问题","date":"2020-01-12T14:10:50.000Z","path":"2020/01/12/JS中的闭包问题/","text":"如果这里有个需求，即写一个计数器的函数，每调用一次计数器返回值加一：如何实现，我们可以先简单的写一下： 1234var index = 1;function counter()&#123; return index++;&#125; 这样写的话，确实每次返回一个递增的数。但是它有以下三个问题： 1.这个 index 放在全局，其他代码可能会对他进行修改 2.如果我需要同时用两个计数器，但这种写法只能满足一个使用，另一个还想用的话就要再写个 counter2 函数，再定义一个 index2 的全局变量。 3.计数器是一个功能，我只希望我的代码里有个 counter 函数就好，其他的最好不要出现。这是稍微有点代码洁癖的都会觉得不爽的。 接下来我们用闭包的方式做一下这个需求： 123456789101112131415function counterCreator() &#123; var index = 1; function counter() &#123; return index ++; &#125; return counter;&#125; // testvar counterA = counterCreator();var counterB = counterCreator();counterA(); // 1counterA(); // 2counterB(); // 1counterB(); // 2 这里的 counterCreator 函数只是把上面的几行代码包起来，然后返回了里面的 counter 函数而已。却能同时解决这么多问题，这就是闭包的魅力！ 铺垫知识执行上下文简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。函数每次执行，都会创建一个称为执行上下文的内部对象（AO 对象，可理解为函数作用域），这个 AO 对象会保存这个函数中所有的变量值和该函数内部定义的函数的引用。函数每次执行时对应的执行上下文都是独一无二的，正常情况下函数执行完毕执行上下文就会被销毁。 作用域链在函数定义的时候，他还获得 [[scope]]。这个是里面包含该函数的作用域链，初始值为引用着上一层作用域链里面所有的作用域，后面执行的时候还会将 AO 对象添加进去 。作用域链就是执行上下文对象的集合，这个集合是链条状的。在函数定义的时候，他还获得 [[scope]]。这个是里面包含该函数的作用域链，初始值为引用着上一层作用域链里面所有的作用域，后面执行的时候还会将 AO 对象添加进去 。作用域链就是执行上下文对象的集合，这个集合是链条状的。 12345678910111213function a () &#123; // （1）创建 a函数的AO对象：&#123; x: undfind, b: function()&#123;...&#125; , 作用域链上层：window的AO对象&#125; var x = 1; function b () &#123; // （3）创建 b函数的AO对象：&#123; y: undfind , 作用域链上层：a函数AO对象&#125; var y = 2; // （4）b函数的AO对象：&#123; y: 2 , 作用域链上层：a函数AO对象&#125; console.log(x, y); // 在 b函数的AO对象中没有找到x, 会到a函数AO对象中查找 &#125; //（2）此时 a函数的AO对象：&#123; x: 1, b: function()&#123;...&#125; , 作用域链上层：window的AO对象&#125; b();&#125;a(); 正常情况函数每次执行后 AO 对象都被销毁，且每次执行时都是生成新的 AO 对象。我们得出这个结论： 只要是这个函数每次调用的结果不一样，那么这个函数内部一定是使用了函数外部的变量。 垃圾回收如何确定哪些内存需要回收，哪些内存不需要回收，这依赖于活对象这个概念。我们可以这样假定：一个对象为活对象当且仅当它被一个根对象 或另一个活对象指向。根对象永远是活对象。 1234567891011function a () &#123; var x = 1; function b () &#123; var y = 2; // b函数执行完了，b函数AO被销毁，y 被回收 &#125; b(); //a 函数执行完了，a函数AO被销毁, x 和 b 都被回收&#125;a();// 这里是在全局下，window中的 a 直到页面关闭才被回收。 分析闭包结构123456789101112131415161718// 生成闭包的函数function counterCreator() &#123; // 被返回函数所依赖的变量 var index = 1; // 被返回的函数 function counter() &#123; return index ++; &#125; return counter;&#125; // 被赋值为闭包函数var counterA = counterCreator(); // 使用counterA(); 闭包的创造函数必定包含两部分： 1.一些闭包函数执行时依赖的变量，每次执行闭包函数时都能访问和修改 2.返回的函数，这个函数中必定使用到上面所说的那些变量123// 被赋值的闭包函数var counterA = counterCreator();var counterB = counterCreator(); 而上面这两句代码很重要，它其实是把闭包函数赋值给了一个变量，这个变量是一个活对象，这活对象引用了闭包函数，闭包函数又引用了 AO 对象，所以这个时候 AO 对象也是一个活对象。此时闭包函数的作用域链得以保存，不会被垃圾回收机制所回收。当我们想重新创建一个新的计数器时，只需要重新再调用一次 counterCreator， 他会新生成了一个新的执行期上下文，所以 counterB 与 counterA 是互不干扰的。counterCreator执行：counterCreator 执行完毕，返回 counter： 总结闭包的原理，就是把闭包函数的作用域链保存了下来。 使用闭包一个简单的防抖函数：第一步，先把闭包的架子搭起来，因为我们已经分析了闭包生成函数内部一定有的两部分内容。 123456function debunce(func, timeout) &#123; // 闭包函数执行时依赖的变量，每次执行闭包函数时都能访问和修改 return function() &#123; // 这个函数最终会被赋值给一个变量 &#125;&#125; 第二步： 把闭包第一次执行的情况写出来 123456789function debunce(func, timeout) &#123; timeout = timeout || 300; return function(...args) &#123; var _this = this; setTimeout(function () &#123; func.apply(_this, args); &#125;, timeout); &#125;&#125; 第三步： 加上一些判断条件。就像我们最开始写计数器的 index 一样，不过这一次你不是把变量写在全局下，而是写在闭包生成器的内部。 12345678910111213141516171819202122232425function debunce(func, timeout) &#123; timeout = timeout || 300; var timer = null; // 被闭包函数使用 return function(...args) &#123; var _this = this; clearTimeout(timer); // 做一些逻辑让每次执行效果可不一致 timer = setTimeout(function () &#123; func.apply(_this, args); &#125;, timeout); &#125;&#125; // 测试：function log(...args) &#123; console.log(&apos;log: &apos;, args);&#125;var d_log = debunce(log, 1000); d_log(1); // 预期：不输出d_log(2); // 预期：1s后输出 setTimeout( function () &#123; d_log(3); // 预期：不输出 d_log(4); // 预期：1s后输出&#125;, 1500) 闭包的应运场景模块化例 NodeJS 模块化原理：NodeJS 会给每个文件包上这样一层函数，引入模块使用 require，导出使用 exports，而那些文件中定义的变量也将留在这个闭包中，不会污染到其他地方。 123(funciton(exports, require, module, __filename, __dirname) &#123; /* 自己写的代码 */&#125;)(); 高阶函数一些使用闭包的经典例子: 节流函数 柯里化（Currying） 组合（Composing） bind 的实现","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheungkooho.github.io/tags/JavaScript/"}]},{"title":"JS数据类型总结","date":"2020-01-07T07:20:58.000Z","path":"2020/01/07/JS数据类型总结/","text":"在ES6之前，JavaScript中有6种数据类型，其中5种简单数据类型（也称基本数据类型）：Undefined Null Boolean Number String；和一种复杂数据类型（也称引用数据类型）：Object。而在ES6中，又新增了一种简单数据类型:symbol。 以下是JavaScript高级程序设计（第三版），就是俗称的小红书中对数据类型的定义： 下面我们就来看看在JS中的数据类型究竟是长什么样的？ ES6之前的数据类型如上所说：ES6之前JavaScript中有6种数据类型：数字（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（Object）。 简单数据类型Undefined 全局属性undefined表示原始值undefined。它是一个JavaScript的 原始数据类型 。undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。一个没有被赋值的变量的类型是undefined。如果方法或者是语句中操作的变量没有被赋值，则会返回undefined。一个函数如果没有使用return语句指定返回值，就会返回一个undefined值。 Null 值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一，在布尔运算中被认为是falsy。值 null 是一个字面量，不像 undefined，它不是全局对象的一个属性。null 是表示缺少的标识，指示变量未指向任何对象。把 null 作为尚未创建的对象，也许更好理解。在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。null 与 undefined 的不同点：当检测 null 或 undefined 时，注意相等（==）与全等（===）两个操作符的区别 ，前者会执行类型转换 123456789typeof null // &quot;object&quot; (因为一些以前的原因而不是&apos;null&apos;)typeof undefined // &quot;undefined&quot;null === undefined // falsenull == undefined // truenull === null // truenull == null // true!null //trueisNaN(1 + null) // falseisNaN(1 + undefined) // true Boolean 布尔表示一个逻辑实体，可以有两个值：true 和 false。 Number 根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。 String JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量。不同于类 C 语言，JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。 复杂数据类型Object对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。 判断数据类型的方法先放一张图 1.typeoftypeof返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。 语法typeof 运算符后接操作数： typeof operand typeof(operand) 详细用法可以参考MDNtypeof可以对基本类型number、string 、boolean、undefined做出准确的判断（null除外，typeof null===“object”，这是由于历史的原因，我就不巴拉巴拉了，其实我也说不清楚😢）；而对于引用类型，除了function之外返回的都是object。但当我们需要知道某个对象的具体类型时，typeof就显得有些力不从心了。 2.instanceof当我们需要知道某个对象的具体类型时,可以用运算符 instanceof，instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。其原理如下： 12345678910模拟instanceof的内部实现过程：instanceof (A,B) = &#123; var L = A.__proto__; var R = B.prototype; if(L === R) &#123; //A的内部属性__proto__指向B的原型对象 return true; &#125; return false;&#125; 从上述过程可以看出，当 A 的 __proto__ 指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子： 12[] instanceof Array; //true[] instanceof Object; //true 我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么从原型链可以看出，[] 的 proto 直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。【注意】：instanceof运算符只能用于对象，不适用原始类型的值。 3.constructorconstructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。例如： 12var f = new F();f.constructor === F;// true 但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失。 123456function F() &#123;&#125;F.prototype = &#123; _name: &apos;Eric&apos;,&#125;;var f = new F();f.constructor === F; // false 因此，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写。 1234567function F() &#123;&#125;F.prototype = &#123; constructor: F, _name: &apos;Eric&apos;,&#125;;var f = new F();f.constructor === F; // true 小结： typeof可以准确地判断出基本类型，但是对于引用类型除function之外返回的都是object； 已知是引用类型的情况可以选用instanceof或constructor方法进行具体类型的判断： instanceof是基于原型链的； constructor 属性易变，不可信赖，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写； ES6新增的Symbol(符号类型) 符号(Symbols)是ECMAScript 第6版新定义的。符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值. 在某些语言当中也有类似的原子类型(Atoms). 你也可以认为为它们是C里面的枚举类型.symbol 是一种基本数据类型 （primitive data type）。Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”new Symbol()”。 每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。 BigInt呃呃，不过好像前段时间又提出了一种新的基本数据类型：BigInt。 BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。BigInt目前是第3阶段提案， 一旦添加到规范中，它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型。","comments":true,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheungkooho.github.io/tags/JavaScript/"}]},{"title":"Vue知识点整理","date":"2020-01-02T08:27:50.000Z","path":"2020/01/02/Vue知识点整理/","text":"一些vue的基础知识点整理，也是面试常问到的东西。 一、对于MVVM的理解MVVM是 Model-View-ViewModel 的缩写。Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。View 代表UI 组件，它负责将数据模型转化成UI 展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 二、Vue的生命周期beforeCreate（创建前） 在数据观测和初始化事件还未开始created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 1.什么是vue生命周期？答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 2.vue生命周期的作用是什么？答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 3.vue生命周期总共有几个阶段？答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。 4.第一次页面加载会触发哪几个钩子？答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。 5.DOM 渲染在 哪个周期中就已经完成？答：DOM 渲染在 mounted 中就已经完成了。 三、Vue实现数据双向绑定的原理vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 1vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 &#123;&#123;&#125;&#125;），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 js实现简单的双向绑定 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;&#125; Object.defineProperty(obj, &apos;txt&apos;, &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById(&apos;txt&apos;).value = newValue document.getElementById(&apos;show&apos;).innerHTML = newValue &#125; &#125;) document.addEventListener(&apos;keyup&apos;, function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt; 四、Vue组件间的参数传递1.父组件与子组件传值父组件传给子组件：子组件通过props方法接受数据;子组件传给父组件：$emit方法传递参数 2.非父子组件间的数据传递，兄弟组件传值eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。） 五、Vue的路由实现模式hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述： “不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。” 六、Vue路由的钩子函数首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next： to：route即将进入的目标路由对象， from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 七、Vuex是什么？怎么使用？哪种功能场景使用？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式(全局状态管理器)。只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。在main.js引入store，注入。新建了一个目录store，….. export 。可以在以下场景中使用：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车（【注】：如果不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的） stateVuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutationsmutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters类似vue的计算属性，主要用来过滤一些数据。 actionactions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 123456789101112131415const store = new Vuex.Store(&#123; //store实例 state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;) modules项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。 1234567891011121314151617const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125; &#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125; &#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB&#125;) 八、Vue-cli如何新增自定义指令1.创建局部指令1234567891011121314151617181920var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; &#125;, // 创建指令(可以多个) directives: &#123; // 指令名称 dir1: &#123; inserted(el) &#123; // 指令中第一个参数是当前使用指令的DOM console.log(el); console.log(arguments); // 对DOM进行操作 el.style.width = &apos;200px&apos;; el.style.height = &apos;200px&apos;; el.style.background = &apos;#000&apos;; &#125; &#125; &#125;&#125;) 2.全局指令12345Vue.directive(&apos;dir2&apos;, &#123; inserted(el) &#123; console.log(el); &#125;&#125;) 3.指令的使用1234&lt;div id=&quot;app&quot;&gt; &lt;div v-dir1&gt;&lt;/div&gt; &lt;div v-dir2&gt;&lt;/div&gt;&lt;/div&gt; 九、Vue如何自定义一个过滤器html代码： 1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; &#123;&#123;msg| capitalize &#125;&#125;&lt;/div&gt; JS代码： 12345678910111213var vm=new Vue(&#123; el:&quot;#app&quot;, data:&#123; msg:&apos;&apos; &#125;, filters: &#123; capitalize: function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 全局定义过滤器 12345Vue.filter(&apos;capitalize&apos;, function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;) 过滤器接收表达式的值 (msg) 作为第一个参数。capitalize 过滤器将会收到 msg的值作为第一个参数。 十、对keep-alive的了解keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。使用方法 12345&lt;keep-alive include=&apos;include_components&apos; exclude=&apos;exclude_components&apos;&gt; &lt;component&gt; &lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 参数解释include - 字符串或正则表达式，只有名称匹配的组件会被缓存exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。使用示例 1234567891011121314&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt; 十一、Vue与Angular以及React的区别1.与AngularJS的区别相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 2.与React的区别相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。 其他一些琐碎的问题1.css只在当前组件起作用答：在style标签中写入scoped即可 例如： 2.v-if 和 v-show 区别答：v-if按照条件是否渲染，v-show是display的block或none； 3.$route和$router的区别答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。 4.vue.js的两个核心是什么？答：数据驱动、组件系统 5.vue几种常用的指令答：v-for 、 v-if 、v-bind、v-on、v-show、v-else 6.vue常用的修饰符？答：.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用 7.v-on 可以绑定多个方法吗？答：可以 8.vue中 key 值的作用？答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。 9.什么是vue的计算属性？答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。 10.vue等单页面应用及其优缺点答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。 11.怎么定义 vue-router 的动态路由? 怎么获取传过来的值答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。 12.Vue 组件 data 为什么必须是函数理解两点： 每个组件都是 Vue 的实例。 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他。 13.Vue computed 实现 从两个问题出发： 建立与其他属性（如：data、 Store）的联系； 属性改变后，通知计算属性重新计算。 实现时，主要如下: 初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。 Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集。 14.Vue complier 实现模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。总的来说，Vue complier 是将 template 转化成一个 render 字符串。可以简单理解成以下步骤： parse 过程，将 template 利用正则转化成 AST 抽象语法树。 optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。 generate 过程，生成 render 字符串。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cheungkooho.github.io/tags/Vue/"}]},{"title":"深入理解BFC","date":"2019-12-28T16:27:32.000Z","path":"2019/12/29/深入理解BFC/","text":"关于BFC，很多人可能都听说过BFC这个东西，大概知道这是个啥东西，相信很多人对此并没有一个非常细致的了解，本文预计篇幅较长，认真，耐着性子看，应该都能够比较深入的理解BFC这个概念的规则、作用以及用法。 什么是BFCBFC概括：可以在心中记住这么一个概念———所谓的BFC就是css布局的一个概念，是一块区域，一个环境。 关于BFC的定义： BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指BFC中的FC。FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文），这里就不再展开了。 通俗一点的方式解释:BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC。 触发BFC的条件？满足下列条件之一就可触发BFC 【1】根元素，即HTML元素 【2】float的值不为none 【3】overflow的值不为visible 【4】display的值为inline-block、table-cell、table-caption 【5】position的值为absolute或fixed 那么BFC到底有啥用呢，我们先来看一下 BFC的作用： 1.自适应两栏布局 2.可以阻止元素被浮动元素覆盖 3.可以包含浮动元素——清除内部浮动 4.分属于不同的BFC时可以阻止margin重叠 BFC这么有用，那它是怎么实现这些个功能的呢？接下来我们就来看一下BFC的布局规则。 BFC布局规则：1.内部的Box会在垂直方向，一个接一个地放置。布局规则1就是我们平常div一行一行块级放置的样式，大家想一下就知道了，这里就不展开了 2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。这里的话如果在同一个BFC中放置两个div，那么根据BFC布局规则1的原则，这两个div是会垂直排列的。这样的话，如果给第一个div（就是上面的div）设置了下边距margin-bottom=200px，而给第二个div（就是下面的div）设置了上边距margin-top=100px，那么此时，两个div盒子之间的距离会是多少呢？答案是200px，这就是因为在同一个BFC的两个相邻Box的margin会发生重叠。那么，这种现象我们也称作外边距合并问题，那么我们该如何处理外边距合并带来的问题呢？ 其实，同样利用BFC就能够很好的解决了。 这里用到BFC的作用4：阻止margin重叠操作方法：给其中一个div外面包一个div，然后通过触发外面这个div的BFC，就可以阻止这两个div的margin重叠 3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。12345&lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; //给这两个子div加浮动，浮动的结果，如果没有清除浮动的话，父div不会将下面两个div包裹，但还是在父div的范围之内。 &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt; 给这两个子div加浮动，浮动的结果，如果没有清除浮动的话，父div不会将下面两个div包裹，但还是在父div的范围之内，左浮是子div的左边接触父div的borderbox的左边，右浮是子div接触父div的borderbox右边，除非设置margin来撑开距离，否则一直是这个规则。 那么这里我们就可以利用BFC来清除浮动带来的不良影响 这里用到BFC的作用3：可以包含浮动元素——清除内部浮动操作方法：给父div加上 overflow: hidden;原理：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内，此时已成功清除浮动。 同时我们也可以给父div添加同方向的浮动，使两个div都位于同一个浮动的BFC区域之中，来达到清除浮动的目的。【注】但是这种方法不推荐使用。 4.BFC的区域不会与float box重叠。12345678910111213141516171819&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;&lt;div class=&quot;text&quot;&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--下面是css代码--&gt;.aside &#123; width: 100px; height: 150px; float: left; background: #f66;&#125;.main &#123; height: 200px; overflow: hidden;//触发main盒子的BFC background: #fcc;&#125;.text&#123; width: 500px;&#125; 在这个例子中，弱国我们将main盒子的overflow:hidden注释掉的话，因为aside盒子带有浮动属性，所以main盒子就会左移到aside盒子下面被覆盖，而如果我们这个时候给main盒子添加了overflow:hidden，从而触发main盒子的BFC，就不会出现这种情况了。这就是我们说的BFC的区域不会与float box重叠。 那么在这里我们讲一下BFC的作用1：自适应两栏布局还是上面的代码，此时BFC的区域不会与float box重叠，因此会根据包含块（父div）的宽度，和aside的宽度，来实现左侧定宽，右列自适应的布局效果。 5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。6.计算BFC的高度时，浮动元素也参与计算","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"看透网页布局本质————CSS盒模型详解","date":"2019-12-27T11:56:24.000Z","path":"2019/12/27/看透网页布局本质————CSS盒模型详解/","text":"页面布局的学习有三大核心，分别是盒子模型、浮动、定位。CSS的盒模型是CSS的基础，同时也是难点，也是面试的考点。所以，学好盒子模型，就成了前端开发者的重中之重，对盒模型有了正确的认识就能很好的帮助我们布局页面。 盒模型的组成部分在菜鸟教程中对CSS盒子模型的描述是这样的： 所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 那么也就是说，我们可以认为页面中的每一个元素标签就是一个个方块，然后这些方块被有序的摆放或者包裹使用，就形成了我们所看到的静态页面，这就是所谓的盒模型布局。所以，网页布局的本质，其实就是盒子的摆放问题。 在CSS中，一个完整的盒子由外边距(margin)、边框(border)、内边距(padding)、实际内容(content)4部分组成。 下面的图片说明了盒子模型(Box Model)： Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 那么，这个盒模型的大小是怎么计算的呢？那么一般来说，我们在普通的盒模型中，设置的width实际上是Content的宽度。所以此时，如果一个盒子在内容外还额外添加了内外边距以及边框的时候，那么这个盒子的总宽度则应该是：总元素的宽度 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距（*注：此处填充即指内边距） 也就是说，我们普通盒子的内边距和边框，是会影响到盒子的实际大小的。那么有没有例外的情况呢？答案是有的，下面这就是padding不撑开盒子的情况【注】：当盒子本身没有设置宽度和高度的时候，此时，对盒子设置padding是不会影响到盒子的实际大小的！！！ 关于盒子外边距margin的应用：外边距可以让块级盒子水平居中，但是必须满足两个条件： 盒子必须制定了宽度（width） 盒子左右的外边距都设置为auto即：margin：0 auto 如果想让行内元素或者行内块元素水平居中，只需要给其父亲添加text-align:center即可 外边距合并的问题使用margin定义的块级元素的垂直外边距时，可能会出现外边距的合并。主要有两种情况： 相邻块元素垂直外边距的合并当两个垂直外边距相遇时，他们将形成一个外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。【注意】：只有普通文档流中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并。 解决方案：只给一个元素margin值 嵌套块元素垂直外边距的塌陷对于两个嵌套关系（父子关系）的块元素，父元素有上外边距的同时，子元素也设置了上外边距，此时父元素会他先较大的外边距值。解决方案： 1.可以给父元素定义上边框 2.给父元素定义内边距 3.给父元素添加overflow:hidden 怪异盒和普通盒的区别很明显，在普通盒子模型中，由于种种原因，比如边框和填充会使得盒子撑破，导致我们在网页布局中可能会造成其他元素的错位，或者在完成某些需求的时候需要花费大量精力去计算内外边距边框和内容的占比，进而导致开发效率受限。 所以，在CSS3中，官方为我们带来了一种新的盒子模型，我们称之为IE盒子模型（或者怪异盒子模型），而把之前的普通盒子称作标准盒子模型。 在CSS3中，我们可以通过box-sizing来置顶盒模型类型，即可指定为content-box(标准盒模型)和border-box(IE盒模型)，这样一来，我们计算盒子大小的方式就发生了改变。 标准盒模型content-box：width = content IE盒模型：width = content + paddings + borders","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"HTML5的语义化理解","date":"2019-12-26T06:32:13.000Z","path":"2019/12/26/HTML5的语义化理解/","text":"要解释HTML5的语义化标签，首先我们来看一下什么是Web语义化。 什么是Web语义化Web语义化是指使用恰当的html标签，class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能够快速理解网页内容。语义化的Web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而使得可以让开发人员读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器能够读懂内容。简单来说，就是利于SEO，便于阅读的维护理解。 总结起来就是： 正确的标签做正确的事情 页面内容结构化 即使没有CSS样式的时候，也容易阅读，便于理解和维护 便于浏览器，搜索引擎解析。利于爬虫标记、利于SEO HTML语义化标签HTML为网页文档内容提供了上下文结构和含义。对于HTML体系而言，Web语义化就是指使用恰当的标签，使页面有良好的结构，让页面元素有含义，其中的标签应该都是语义化的定义了文档的结构。 1234567891011121314151617181920212223&lt;html&gt; &lt;body&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;h1 - WEB 语义化&lt;/h1&gt; &lt;/header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;nav1 - HTML语义化&lt;/li&gt; &lt;li&gt;nav2 - CSS语义化&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;section&gt; section1 - HTML语义化 &lt;/section&gt; &lt;section&gt; section2 - CSS语义化 &lt;/section&gt; &lt;time datetime=&quot;2018-03-23&quot; pubdate&gt;time - 2018年03月23日&lt;/time&gt; &lt;footer&gt; footer - by 小维&lt;/footer&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; HTML语义化标签包括body/article/nav/aside/section/header/footer/hgroup,还有h1-h6/address等 下面我们来简单看一下常用的HTML语义化标签 header元素header代表“网页”或者“section”的页眉，通常包含h1-h6 元素或者 hgroup, 作为整个页面或者一个内容快的标题。也可以包裹一节的目录部分，一个搜索框，一个nav，或者相关logo。如下： 123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;h1&gt; &lt;h2&gt;网站副标题&lt;/h2&gt; &lt;/hgroup&gt;&lt;header&gt; 注意事项： 可以是“网页”或者任意“section”的头部部分 没有个数限制 如果hgroup或者h1-h6自己就能工作得很好，那么就没必要用header。 hgroup元素hgroup 元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题组合。如下： 1234&lt;hgroup&gt; &lt;h1&gt;这是一个主标题&lt;/h1&gt; &lt;h2&gt;这是一个副标题&lt;/h2&gt;&lt;/hgroup&gt; 注意事项： 如果只需要一个h1-h6标签就不用hgroup 如果有连续多个h1-h6标签就用hgroup 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签 footer元素footer元素代表“网页”或任意“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果footer元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。如下： 123&lt;footer&gt; COPYRGHT@CheungKH&lt;/footer&gt; 注意事项： 可以是“网页”或者任意“section”的底部部分 没有个数限制，除了包裹的内容不一样，其他跟header类似 nav元素nav 元素代表页面的导航链接区域。用于定义页面的主要导航部分。 代码示例： 123456&lt;nav&gt; &lt;ul&gt; &lt;li&gt;HTML语义化&lt;/li&gt; &lt;li&gt;CSS 语义化&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 侧边栏上目录、面包屑导航、搜索样式、或者下一篇上一篇文章我们可能会想要用到nav，但是事实上规范上说nav只能用在页面主要导航部分上。页脚区域中的链接列表，虽然指向不同网站的不同区域，譬如服务条款，版权页等，这些footer元素就能够用了。 注意事项： 用于整个页面的主要导航部分，不适合就不要用nav元素了 article元素article 代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。除了它的内容，article会有一个标题(通常会在header里)，一个footer页脚。代码示例： 1234567&lt;article&gt; &lt;h1&gt;你好，我是这边文章的标题&lt;/h1&gt; &lt;p&gt;你好，我是文章的内容&lt;/p&gt; &lt;footer&gt; &lt;p&gt;最终解释权归XXX所有&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt; 下面这是一个最简单的例子，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论： 123456789101112131415161718192021222324&lt;article&gt; &lt;header&gt; &lt;h1&gt;web 语义化&lt;/h1&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2018-03-23&quot;&gt;2018-03-23&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;文章内容..&lt;/p&gt; &lt;article&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: 专业水军&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2018-03-23T15:10-08:00&quot;&gt;~1 min ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;还行&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: 大水怪&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2018-03-23T15:10-08:00&quot;&gt;~1 hour ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;楼上说的对&lt;/p&gt; &lt;/article&gt; &lt;/article&gt;&lt;/article&gt; article 内部可以嵌套article，表示评论或者其他跟文章有关联的内容。article内部还可以嵌套section，如下： 123456789101112&lt;article&gt; &lt;h1&gt;web语义化&lt;/h1&gt; &lt;p&gt;什么是语义化？&lt;/p&gt; &lt;section&gt; &lt;h2&gt;语义化详解&lt;/h2&gt; &lt;p&gt;语义化就是。。。&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;语义化特点&lt;/h2&gt; &lt;p&gt;语义化特点就是。。。&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 文章内section是独立的部分，但是它们只能算是组成整体的一部分，从属关系，article是大主体，section是构成这个大主体的一个部分。 注意事项： 自身独立情况下：用article 是相关内容： 用section 没有语义的： 用div section元素section 元素代表文档中的“节”或“段”，“段”可以是指一片文章里按照主题的分段；“节”可以是指一个页面里的分组。section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。代码示例： 1234567891011&lt;section&gt; &lt;h1&gt;section是啥？&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h2&gt; &lt;p&gt;section的介绍&lt;/p&gt; &lt;section&gt; &lt;h3&gt;关于其他&lt;/h3&gt; &lt;p&gt;关于其他section的介绍&lt;/p&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt; 注意事项： 一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。 表示文档中的节或者段。 acticle、nav、aside可以理解为特殊的section，如果可以用article、nav、aside就不要用section，没有实际意义的就用div aside元素aside 元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料，标签，名词解释等。在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。代码示例： 1234567&lt;article&gt; &lt;p&gt;内容&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;CheungKh...&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; 注意事项： aside 在 article 内表示主要内容的附属信息。 在article之外侧可以做侧边栏，没有article与之对应，最好不用 如果是广告，其他日志链接或者其他分类导航也可以用。 HTML语义化小结总之，HTML语义化是反对大篇幅使用无语义化的div+span+class，而鼓励使用HTML定义好的语义化标签。 当然，如果需要兼容低版本的IE浏览器，比如说IE8以及以下，那就需要考虑一些HTML5标签兼容性解决方案了。","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"https://cheungkooho.github.io/tags/HTML/"}]},{"title":"div+CSS布局中常用标签和属性","date":"2019-11-25T12:06:43.000Z","path":"2019/11/25/div+CSS布局中常用标签和属性/","text":"下面这些是div+CSS进行布局时常用的标签和属性 页面布局常用标签无意义块状元素标签 div无意义行内元素标签 span段落标签 p无序列表 ul列表项 li超链接列表 a图片标签 img斜体标签 i粗体标签 b 页面布局常用选择器id选择器 #id类选择器 .class关系选择器 div p\\div&gt;p\\div,p伪类选择器 :hover结构性味蕾选择器 E:after\\E:before\\E:nth-child()\\E:first-child\\E:last-child 页面布局常用基本属性字体属性： font-sise文本属性： text-decoration\\text-align首行缩进： text-indent行高： line-height宽高属性： width\\height\\min-height\\max-height背景属性： background列表属性： list-style字体颜色： color 页面布局常用应用属性定位属性： position布局属性： display *浮动属性： float\\clear盒子模型： border\\margin\\padding圆角边框： border-radius阴影： text-shadow\\box-shadow","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"CSS各种居中方法","date":"2019-11-25T05:06:43.000Z","path":"2019/11/25/CSS各种居中方法/","text":"CSS布局中常用的各种居中方法 一、水平居中1、文本/行内元素/行内块级元素原理：text-align只控制行内内容(文字、行内元素、行内块级元素)如何相对他的块父元素对齐 123#parent&#123; text-align: center;&#125; 优缺点·优点：简单快捷，容易理解，兼容性非常好·缺点：只对行内内容有效；属性会继承影响到后代行内内容；如果子元素宽度大于父元素宽度则无效，只有后代行内内容中宽度小于设置text-align属性的元素宽度的时候，才会水平居中 2、单个块级元素原理：根据规范，有这么一种情况：在margin有节余的同时如果左右margin设置了auto，将会均分剩余空间。另外，如果上下的margin设置了auto，其计算值为0 1234#son&#123; width: 100px; /*必须定宽*/ margin: 0 auto;&#125; 优缺点·优点：简单；兼容性好·缺点：必须定宽，并且值不能为auto；宽度要小于父元素，否则无效 3、多个块级元素原理：text-align只控制行内内容(文字、行内元素、行内块级元素)，如何相对他的块父元素对齐 123456#parent&#123; text-align: center;&#125;.son&#123; display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/&#125; 优缺点·优点：简单，容易理解，兼容性非常好·缺点：只对行内内容有效；属性会继承影响到后代行内内容；块级改为inline-block，换行、空格会产生元素间隔 4、使用绝对定位实现原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的 1234567891011121314#parent&#123; height: 200px; width: 200px; /*定宽*/ position: relative; /*父相*/ background-color: #f00;&#125;#son&#123; position: absolute; /*子绝*/ left: 50%; /*父元素宽度一半,这里等同于left:100px*/ transform: translateX(-50%); /*自身宽度一半,等同于margin-left: -50px;*/ width: 100px; /*定宽*/ height: 100px; background-color: #00ff00;&#125; 优缺点·优点：使用margin-left兼容性好；不管是块级还是行内元素都可以实现·缺点：代码较多；脱离文档流；使用margin-left需要知道宽度值；使用transform兼容性不好（ie9+） 5、任意个元素(flex)原理：就是设置当前主轴对齐方式为居中。说不上为什么，flex无非就是主轴侧轴是重点，然后就是排列方式的设置 1234#parent&#123; display: flex; justify-content: center;&#125; 优缺点·优点：功能强大；简单方便；容易理解·缺点：PC端兼容性不好，移动端（Android4.0+） 本章小结·对于水平居中，我们应该先考虑，哪些元素有自带的居中效果，最先想到的应该就是 text-align:center 了，但是这个只对行内内容有效，所以我们要使用 text-align:center 就必须将子元素设置为 display: inline; 或者 display: inline-block; ；·其次就是考虑能不能用margin: 0 auto; ，因为这都是一两句代码能搞定的事，实在不行就是用绝对定位去实现了。·移动端能用flex就用flex，简单方便，灵活并且功能强大，无愧为网页布局的一大利器 二、垂直居中1、单行文本/行内元素/块级行内元素原理：line-height的最终表现是通过inline box实现的，而无论inline box所占据的高度是多少（无论比文字大还是比文字小），其占据的空间都是与文字内容公用水平中垂线的。 1234#parent&#123; height: 150px; line-height: 150px; /*与height等值*/&#125; 优缺点·优点：简单；兼容性好·缺点：只能用于单行行内内容；要知道高度的值 2、多行文本/行内元素/行内块级元素原理同上 1234#parent&#123; /*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/ height: 150px; line-height: 30px; /*元素在页面呈现为5行,则line-height的值为height/5*/&#125; 优缺点·优点：简单；兼容性好·缺点：只能用于行内内容；需要知道高度和最终呈现多少行来计算出line-height的值，建议用span包裹多行文本 3、图片原理：vertical-align和line-height的基友关系 123456#parent&#123; height: 150px; line-height: 150px; font-size: 0;&#125;img #son&#123;vertical-align: middle;&#125; /*默认是基线对齐，改为middle*/ 优缺点·优点：简单；兼容性好·缺点：需要添加font-size: 0; 才可以完全的垂直居中；不过需要主要，html#parent包裹img之间需要有换行或空格 4、单个块级元素HTML 123&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 4.1、使用tabel-cell实现原理：CSS Table，使表格内容对齐方式为middle 1234#parent&#123; display: table-cell; vertical-align: middle;&#125; 优缺点·优点：简单；宽高不定；兼容性好（ie8+）·缺点：设置tabl-cell的元素，宽度和高度的值设置百分比无效，需要给它的父元素设置display: table; 才生效；table-cell不感知margin，在父元素上设置table-row等属性，也会使其不感知height；设置float或position会对默认布局造成破坏，可以考虑为之增加一个父div定义float等属性；内容溢出时会自动撑开父元素 4.2、使用绝对定位12345678910111213141516171819202122232425262728293031/*原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的*/#parent&#123; height: 150px; position: relative; /*父相*/&#125;#son&#123; position: absolute; /*子绝*/ top: 50%; /*父元素高度一半,这里等同于top:75px;*/ transform: translateY(-50%); /*自身高度一半,这里等同于margin-top:-25px;*/ height: 50px;&#125;/*优缺点- 优点：使用margin-top兼容性好；不管是块级还是行内元素都可以实现- 缺点：代码较多；脱离文档流；使用margin-top需要知道高度值；使用transform兼容性不好（ie9+）*/或/*原理：当top、bottom为0时,margin-top&amp;bottom会无限延伸占满空间并且平分*/#parent&#123;position: relative;&#125;#son&#123; position: absolute; margin: auto 0; top: 0; bottom: 0; height: 50px;&#125;/*优缺点- 优点：简单;兼容性较好(ie8+)- 缺点：脱离文档流*/ 4.3、使用flex实现原理：flex设置对齐方式罢了 1234567891011121314#parent&#123; display: flex; align-items: center;&#125;或#parent&#123;display: flex;&#125;#son&#123;align-self: center;&#125;或/*原理：这个尚未搞清楚，应该是flex使margin上下边界无限延伸至剩余空间并平分了*/#parent&#123;display: flex;&#125;#son&#123;margin: auto 0;&#125; 优缺点·优点：简单灵活；功能强大·缺点：PC端兼容性不好，移动端（Android4.0+） 5、任意个元素原理：flex设置对齐方式 123456789101112131415161718192021#parent&#123; display: flex; align-items: center;&#125;或#parent&#123; display: flex;&#125;.son&#123; align-self: center;&#125;或 #parent&#123; display: flex; flex-direction: column; justify-content: center;&#125; 优缺点·优点：简单灵活；功能强大·缺点：PC端兼容性不好，移动端（Android4.0+） 本章小结·对于垂直居中，最先想到的应该就是 line-height 了，但是这个只能用于行内内容；·其次就是考虑能不能用vertical-align: middle; ，不过这个一定要熟知原理才能用得顺手，建议看下vertical-align和line-height的基友关系 ；·然后便是绝对定位，虽然代码多了点，但是胜在适用于不同情况；·移动端兼容性允许的情况下能用flex就用flex 水平垂直居中1、行内元素/行内块级元素/图片原理：text-align: center; 控制行内内容相对于块父元素水平居中,然后就是line-height和vertical-align的基友关系使其垂直居中，font-size: 0; 是为了消除近似居中的bug 12345678910#parent&#123; height: 150px; line-height: 150px; /*行高的值与height相等*/ text-align: center; font-size: 0; /*消除幽灵空白节点的bug*/&#125;#son&#123; /*display: inline-block;*/ /*如果是块级元素需改为行内或行内块级才生效*/ vertical-align: middle;&#125; 优缺点·优点：代码简单；兼容性好（ie8+）·缺点：只对行内内容有效；需要添加font-size: 0; 才可以完全的垂直居中；不过需要注意html中#parent包裹#son之间需要有换行或空格；熟悉line-height和vertical-align的基友关系较难 2、table-cell原理：CSS Table，使表格内容垂直对齐方式为middle,然后根据是行内内容还是块级内容采取不同的方式达到水平居中 123456789101112#parent&#123; height: 150px; width: 200px; display: table-cell; vertical-align: middle; /*text-align: center;*/ /*如果是行内元素就添加这个*/&#125;#son&#123; /*margin: 0 auto;*/ /*如果是块级元素就添加这个*/ width: 100px; height: 50px;&#125; 优缺点·优点：简单；适用于宽度高度未知情况；兼容性好（ie8+）·缺点：设置tabl-cell的元素，宽度和高度的值设置百分比无效，需要给它的父元素设置display: table; 才生效；table-cell不感知margin，在父元素上设置table-row等属性，也会使其不感知height；设置float或position会对默认布局造成破坏，可以考虑为之增加一个父div定义float等属性；内容溢出时会自动撑开父元素 3、button作为父元素原理：button的默认样式，再把需要居中的元素表现形式改为行内或行内块级就好 123456789button#parent&#123; /*改掉button默认样式就好了,不需要居中处理*/ height: 150px; width: 200px; outline: none; border: none;&#125;#son&#123; display: inline-block; /*button自带text-align: center,改为行内水平居中生效*/&#125; 优缺点·优点：简单方便，充分利用默认样式·缺点：只适用于行内内容；需要清除部分默认样式；水平垂直居中兼容性很好，但是ie下点击会有凹陷效果！ 4、绝对定位原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到几何上的水平垂直居中 12345678910#parent&#123; position: relative;&#125;#son&#123; position: absolute; top: 50%; left: 50%; /*定宽高时等同于margin-left:负自身宽度一半;margin-top:负自身高度一半;*/ transform: translate(-50%,-50%); &#125; 优缺点·优点：使用margin兼容性好；不管是块级还是行内元素都可以实现·缺点：代码较多；脱离文档流；使用margin需要知道宽高；使用transform兼容性不好（ie9+） 5、绝对居中原理：当top、bottom为0时,margin-top&amp;bottom设置auto的话会无限延伸占满空间并且平分；当left、right为0时,margin-left&amp;right设置auto的话会无限延伸占满空间并且平分 12345678910111213#parent&#123; position: relative;&#125;#son&#123; position: absolute; margin: auto; width: 100px; height: 50px; top: 0; bottom: 0; left: 0; right: 0;&#125; 优缺点·优点：无需关注宽高；兼容性较好(ie8+)·缺点：代码较多；脱离文档流 6、flex原理：flex设置对齐方式 123456789101112131415161718192021222324#parent&#123; display: flex;&#125;#son&#123; margin: auto;&#125;或#parent&#123; display: flex; justify-content: center; align-items: center;&#125;或#parent&#123; display: flex; justify-content: center;&#125;#son&#123; align-self: center;&#125; 优缺点·优点：简单灵活；功能强大·缺点：PC端兼容性不好，移动端（Android4.0+） 7、视窗居中原理：vh为视口单位，视口即文档可视的部分，50vh就是视口高度的50/100，设置50vh上边距再 12345#son&#123; /*0如果去掉，则会多出滚动条并且上下都是50vh的margin。如果去掉就给body加上overflow:hidden;*/ margin: 50vh auto 0; transform: translateY(-50%);&#125; 优缺点·优点：简单；容易理解；两句代码达到屏幕水平垂直居中·缺点：兼容性不好（ie9+，Android4.4+） 本章小结·一般情况下，水平垂直居中，我们最常用的就是绝对定位加负边距了，缺点就是需要知道宽高，使用transform倒是可以不需要，但是兼容性不好（ie9+）；·其次就是绝对居中，绝对定位设置top、left、right、bottom为0，然后margin:auto; 让浏览器自动平分边距以达到水平垂直居中的目的；·如果是行内/行内块级/图片这些内容，可以优先考虑line-height和vertical-align 结合使用，不要忘了还有text-align ，这个方法代码其实不多，就是理解原理有点困难，想要熟练应对各种情况还需好好研究；·移动端兼容性允许的情况下能用flex就用flex。","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"CSS浮动清除","date":"2019-11-21T13:06:43.000Z","path":"2019/11/21/CSS浮动清除/","text":"什么是CSS清除浮动？在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 引用W3C的例子，news容器没有包围浮动的元素。 1234567891011121314151617.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;; 清除浮动方法方法一：使用带clear属性的空元素在浮动元素后使用一个空元素如，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用或来进行清理。 12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.clear &#123; clear: both; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 优点：简单，代码少，浏览器兼容性好。缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。 方法二：使用CSS的overflow属性给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 12345678910111213141516171819.news &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 方法三：给浮动的元素的容器添加浮动给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 方法四：使用邻接元素处理什么都不做，给浮动元素后面的元素添加clear属性。 12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.content&#123; clear:both; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class=&quot;content&quot;&gt;***&lt;/div&gt;&lt;/div&gt; 注意这里的div.content有内容。 方法五：使用CSS的:after伪元素结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 123456789101112131415161718192021222324252627282930.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.clearfix:after&#123; content: &quot;020&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; /* 触发 hasLayout */ zoom: 1; &#125;&lt;div class=&quot;news clearfix&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。 总结通过上面的例子，我们不难发现清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。 在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。 最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"web网页版简易音乐播放器实现","date":"2019-11-18T13:20:42.000Z","path":"2019/11/18/web网页版简易音乐播放器实现/","text":"下面我们做一个网页版简易音乐播放器Lat’s do it! HTML代码12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;音乐播放器&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;音乐播放器&lt;/header&gt; &lt;section&gt; &lt;ul&gt; &lt;li&gt;Here We Are Again&lt;/li&gt; &lt;li&gt;不谓侠&lt;/li&gt; &lt;li&gt;多想在平庸的生活拥抱你&lt;/li&gt; &lt;li&gt;浪子回头&lt;/li&gt; &lt;li&gt;那个女孩&lt;/li&gt; &lt;li&gt;那女孩对我说&lt;/li&gt; &lt;li&gt;平胸女子&lt;/li&gt; &lt;li&gt;情深深雨濛濛&lt;/li&gt; &lt;li&gt;雅俗共赏&lt;/li&gt; &lt;li&gt;野狼disco&lt;/li&gt; &lt;li&gt;这一生关于你的风景&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;audio src=&quot;&quot; id=&quot;ado&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; &lt;footer&gt; 当前播放的是：&lt;span id=&quot;con&quot;&gt;&lt;/span&gt; &lt;/footer&gt; &lt;/body&gt; &lt;script src=&quot;js/index.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/html&gt; 添加CSS样式123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 写样式通常首先-清空所有标签的内外边距 */*&#123; margin: 0; padding: 0;&#125;/* */body&#123; width: 31.25rem; overflow: auto; /* overflow 属性规定当内容溢出元素框时发生的事情 */ margin: 20px auto; /* 外边距 上下20 水平居中 */&#125;/* 设置头部和底部样式 */header,footer&#123; height: 40px; line-height: 40px; /* 与模块同高 可以字体上下居中显示 */ background: #808080; text-align: center; /* 文本居中 */&#125;/* 给音乐列表写样式 */li&#123; height: 50px; line-height: 50px; border: 1px solid red; /* 添加边框属性 */ border-top: none; /* 上下线条重合 so清空上线条 */ font-size: 15px; /* 字体大小设置 */ text-indent: 20px; /* text-indent 属性规定文本块中首行文本的缩进。 */ /* 注释：允许使用负值。如果使用负值，那么首行会被缩进到左边 */ list-style: none; /* 清空一下列表的样式-列表前方的点或数字 */&#125;/* 音频文件的样式设置 */#ado&#123; width: 100%; height: 20px; margin-top: 10px;&#125;/* 设置控制列表的类名样式 */.sty&#123; background: #FF0000;&#125; JAVAScript代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 通过js实现音乐的播放 --&gt;var lis = document.getElementsByTagName(&apos;li&apos;); //获取dom元素var ado = document.getElementById(&apos;ado&apos;);var con = document.getElementById(&apos;con&apos;);//创建数组存放音乐文件路径，通过下标找到相应文件var arr = [ &apos;audio/Here We Are Again.mp3&apos;, &apos;audio/不谓侠.mp3&apos;, &apos;audio/多想在平庸的生活拥抱你.mp3&apos;, &apos;audio/浪子回头.mp3&apos;, &apos;audio/那个女孩.mp3&apos;, &apos;audio/那女孩对我说.mp3&apos;, &apos;audio/平胸女子.mp3&apos;, &apos;audio/情深深雨濛濛.mp3&apos;, &apos;audio/雅俗共赏.mp3&apos;, &apos;audio/野狼disco.mp3&apos;, &apos;audio/这一生关于你的风景.mp3&apos;]//通过循环遍历的方式添加点击事件for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function()&#123; for (var i = 0; i &lt; lis.length; i++) &#123; if (this === lis[i]) &#123; lis[i].className = &apos;sty&apos;; ado.src = arr[i]; ado.play(); con.innerHTML = lis[i].innerHTML; var a = i; //通过ended事件监听是否播放完毕 ado.onended = function()&#123; a++; if(a&gt;lis.length-1)&#123; a = 0; &#125; //通过for循环清空所有样式列表 for (var j = 0; j &lt; lis.length; j++) &#123; lis[j].className = &apos;&apos;; &#125; //通过下标a给相应的列表进行样式的修饰和音乐的播放 con.innerHTML = lis[a].innerHTML; ado.src = arr[a]; ado.play(); lis[a].className = &apos;sty&apos;; &#125; &#125; else&#123; lis[i].className = &apos;&apos;; &#125; &#125; &#125;&#125; 完成效果 注释把音乐文件放进相应的目录下即可。","comments":true,"tags":[{"name":"小玩意儿","slug":"小玩意儿","permalink":"https://cheungkooho.github.io/tags/%E5%B0%8F%E7%8E%A9%E6%84%8F%E5%84%BF/"}]},{"title":"HTML基础标签","date":"2019-11-17T12:57:30.000Z","path":"2019/11/17/HTML基础标签/","text":"HTML基础标签 标签 描述 &lt;!DOCTYPE&gt; 定义文档类型。 &lt;html&gt; 定义 HTML 文档。 &lt;title&gt; 定义文档的标题。 &lt;body&gt; 定义文档的主体。 &lt;h1&gt; to &lt;h6&gt; 定义 HTML 标题。 &lt;p&gt; 定义段落。 &lt;br&gt; 定义简单的折行。 &lt;hr&gt; 定义水平线。 &lt;!--...--&gt; 定义注释。 &lt;!DOCTYPE&gt; 标签定义和用法&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 &lt;html&gt; 标签之前。 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。 HTML5 不基于 SGML，所以不需要引用 DTD。 提示：请始终向 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，这样浏览器才能获知文档类型。 HTML 4.01 与 HTML5 之间的差异在 HTML 4.01 中有三种 &lt;!DOCTYPE&gt; 声明。在 HTML5 中只有一种：&lt;!DOCTYPE html&gt; 提示和注释注释：&lt;!DOCTYPE&gt; 声明没有结束标签。提示：&lt;!DOCTYPE&gt; 声明对大小写不敏感。 &lt;html&gt; 标签定义和用法此元素可告知浏览器其自身是一个 HTML 文档。 &lt;html&gt; 与 &lt;/html&gt; 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。 提示和注释注释：即使 html 元素是文档的根元素，它也不包含 doctype 元素。doctype 元素必须位于 html 元素之前。 属性 属性 值 描述 manifest url 定义一个 URL，在这个 URL 上描述了文档的缓存信息。 xmlns 定义 XML namespace 属性。 &lt;title&gt; 标签定义和用法&lt;title&gt; 元素可定义文档的标题。 浏览器会以特殊的方式来使用标题，并且通常把它放置在浏览器窗口的标题栏或状态栏上。同样，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。 提示和注释提示：&lt;title&gt; 标签是 &lt;head&gt; 标签中唯一要求包含的东西。 标准属性&lt;title&gt; 标签支持以下标准属性： 属性 值 描述 dir rtl ltr 规定元素中内容的文本方向。 lang language_code 规定元素中内容的语言代码。 xml:lang language_code 规定 XHTML 文档中元素内容的语言代码。 &lt;body&gt; 标签定义和用法body 元素定义文档的主体。 body 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） HTML 与 XHTML 之间的差异在 HTML 4.01 中，所有 body 元素的“呈现属性”均不被赞成使用。 在 XHTML 1.0 Strict DTD 中，所有 body 元素的“呈现属性”均不被支持。 可选的属性 属性 值 描述 alink rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。 规定文档中活动链接（active link）的的颜色。 background URL 不赞成使用。请使用样式取代它。 bgcolor rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。 规定文档的背景颜色。 link rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。 规定文档中未访问链接的默认颜色。 text rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。 规定文档中所有文本的颜色。 vlink rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。规定文档中已被访问链接的颜色。 &lt;h1&gt; 到 &lt;h6&gt; 标签定义和用法&lt;h1&gt; - &lt;h6&gt; 标签可定义标题。&lt;h1&gt; 定义最大的标题。&lt;h6&gt; 定义最小的标题。 由于 h 元素拥有确切的语义，因此请您慎重地选择恰当的标签层级来构建文档的结构。因此，请不要利用标题标签来改变同一行中的字体大小。相反，我们应当使用层叠样式表定义来达到漂亮的显示效果。 标准属性 id, class, title, style, dir, lang, xml:lang 事件属性 onclick, ondblclick, onmousedown, onmouseup, onmouseover,onmousemove, onmouseout, onkeypress, onkeydown, onkeyup &lt;p&gt; 标签定义和用法&lt;p&gt; 标签定义段落。 p 元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，您也可以在样式表中规定。 &lt;br&gt; 标签定义和用法&lt;br&gt; 可插入一个简单的换行符。 &lt;br&gt; 标签是空标签（意味着它没有结束标签，因此这是错误的：&lt;br&gt;&lt;/br&gt;）。在 XHTML 中，把结束标签放在开始标签中，也就是 &lt;br /&gt;。 请注意，&lt;br&gt; 标签只是简单地开始新的一行，而当浏览器遇到 &lt;p&gt; 标签时，通常会在相邻的段落之间插入一些垂直的间距。 clear 属性如果您希望文本流在内联表格或图像的下一行继续输出，请使用 clear 属性，该属性有三个可选的值：left、right 或者 all，每个值都代表一个边界或两边的边界。 提示和注释注释：请使用 &lt;br&gt; 来输入空行，而不是分割段落。 &lt;hr&gt; 标签定义和用法&lt;hr&gt; 标签在 HTML 页面中创建一条水平线。 水平分隔线（horizontal rule）可以在视觉上将文档分隔成各个部分。 可选的属性 属性 值 描述 align centerleftright 不赞成使用。请使用样式取代它。 规定 hr 元素的对齐方式。 noshade noshade 不赞成使用。请使用样式取代它。规定 hr 元素的颜色呈现为纯色。 size pixels 不赞成使用。请使用样式取代它。规定 hr 元素的高度（厚度）。 width pixels% 不赞成使用。请使用样式取代它。规定 hr 元素的宽度。 &lt;!--...--&gt;标签定义和用法注释标签用于在源代码中插入注释。注释不会显示在浏览器中。 您可使用注释对您的代码进行解释，这样做有助于您在以后的时间对代码的编辑。当您编写了大量代码时尤其有用。 使用注释标签来隐藏浏览器不支持的脚本也是一个好习惯（这样就不会把脚本显示为纯文本）。","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"https://cheungkooho.github.io/tags/HTML/"}]},{"title":"Markdown语法的简要规则","date":"2019-11-15T16:33:07.000Z","path":"2019/11/16/Markdown语法的简要规则/","text":"Markdown简介 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。 标题标题是每篇文章都需要也是最常用的格式。在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。‘# 一级标题’‘## 二级标题’‘### 三级标题’以此类推，总共六级标题。建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号，要和文字之间加上一个字符的空格。 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。 例如这样 只需要在文本前加入 &gt; 这种尖括号（大于号）即可 图片与链接插入链接与插入图片的语法很像，区别在一个 !号图片为：![]()链接为：[]() 插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 例如：这里是粗体 这里是斜体 表格表格是我觉得 Markdown 比较累人的地方，例子如下： | Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 这种语法生成的表格如下： 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例： 使用 tab 键即可缩进。 分割线分割线的语法只需要三个 * 号或者三个-，例如： ***--- 到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。","comments":true,"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://cheungkooho.github.io/tags/Markdown/"}]},{"title":"Hello World","date":"2019-11-15T09:30:29.139Z","path":"2019/11/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]