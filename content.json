[{"title":"深入理解BFC","date":"2019-12-28T16:27:32.000Z","path":"2019/12/29/深入理解BFC/","text":"关于BFC，很多人可能都听说过BFC这个东西，大概知道这是个啥东西，相信很多人对此并没有一个非常细致的了解，本文预计篇幅较长，认真，耐着性子看，应该都能够比较深入的理解BFC这个概念的规则、作用以及用法。 什么是BFCBFC概括：可以在心中记住这么一个概念———所谓的BFC就是css布局的一个概念，是一块区域，一个环境。 关于BFC的定义： BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指BFC中的FC。FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文），这里就不再展开了。 通俗一点的方式解释:BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC。 触发BFC的条件？满足下列条件之一就可触发BFC 【1】根元素，即HTML元素 【2】float的值不为none 【3】overflow的值不为visible 【4】display的值为inline-block、table-cell、table-caption 【5】position的值为absolute或fixed 那么BFC到底有啥用呢，我们先来看一下 BFC的作用： 1.自适应两栏布局 2.可以阻止元素被浮动元素覆盖 3.可以包含浮动元素——清除内部浮动 4.分属于不同的BFC时可以阻止margin重叠 BFC这么有用，那它是怎么实现这些个功能的呢？接下来我们就来看一下BFC的布局规则。 BFC布局规则：1.内部的Box会在垂直方向，一个接一个地放置。布局规则1就是我们平常div一行一行块级放置的样式，大家想一下就知道了，这里就不展开了 2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。这里的话如果在同一个BFC中放置两个div，那么根据BFC布局规则1的原则，这两个div是会垂直排列的。这样的话，如果给第一个div（就是上面的div）设置了下边距margin-bottom=200px，而给第二个div（就是下面的div）设置了上边距margin-top=100px，那么此时，两个div盒子之间的距离会是多少呢？答案是200px，这就是因为在同一个BFC的两个相邻Box的margin会发生重叠。那么，这种现象我们也称作外边距合并问题，那么我们该如何处理外边距合并带来的问题呢？ 其实，同样利用BFC就能够很好的解决了。 这里用到BFC的作用4：阻止margin重叠操作方法：给其中一个div外面包一个div，然后通过触发外面这个div的BFC，就可以阻止这两个div的margin重叠 3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。12345&lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; //给这两个子div加浮动，浮动的结果，如果没有清除浮动的话，父div不会将下面两个div包裹，但还是在父div的范围之内。 &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt; 给这两个子div加浮动，浮动的结果，如果没有清除浮动的话，父div不会将下面两个div包裹，但还是在父div的范围之内，左浮是子div的左边接触父div的borderbox的左边，右浮是子div接触父div的borderbox右边，除非设置margin来撑开距离，否则一直是这个规则。 那么这里我们就可以利用BFC来清除浮动带来的不良影响 这里用到BFC的作用3：可以包含浮动元素——清除内部浮动操作方法：给父div加上 overflow: hidden;原理：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内，此时已成功清除浮动。 同时我们也可以给父div添加同方向的浮动，使两个div都位于同一个浮动的BFC区域之中，来达到清除浮动的目的。【注】但是这种方法不推荐使用。 4.BFC的区域不会与float box重叠。12345678910111213141516171819&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;&lt;div class=&quot;text&quot;&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--下面是css代码--&gt;.aside &#123; width: 100px; height: 150px; float: left; background: #f66;&#125;.main &#123; height: 200px; overflow: hidden;//触发main盒子的BFC background: #fcc;&#125;.text&#123; width: 500px;&#125; 在这个例子中，弱国我们将main盒子的overflow:hidden注释掉的话，因为aside盒子带有浮动属性，所以main盒子就会左移到aside盒子下面被覆盖，而如果我们这个时候给main盒子添加了overflow:hidden，从而触发main盒子的BFC，就不会出现这种情况了。这就是我们说的BFC的区域不会与float box重叠。 那么在这里我们讲一下BFC的作用1：自适应两栏布局还是上面的代码，此时BFC的区域不会与float box重叠，因此会根据包含块（父div）的宽度，和aside的宽度，来实现左侧定宽，右列自适应的布局效果。 5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。6.计算BFC的高度时，浮动元素也参与计算","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"看透网页布局本质————CSS盒模型详解","date":"2019-12-27T11:56:24.000Z","path":"2019/12/27/看透网页布局本质————CSS盒模型详解/","text":"页面布局的学习有三大核心，分别是盒子模型、浮动、定位。CSS的盒模型是CSS的基础，同时也是难点，也是面试的考点。所以，学好盒子模型，就成了前端开发者的重中之重，对盒模型有了正确的认识就能很好的帮助我们布局页面。 盒模型的组成部分在菜鸟教程中对CSS盒子模型的描述是这样的： 所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 那么也就是说，我们可以认为页面中的每一个元素标签就是一个个方块，然后这些方块被有序的摆放或者包裹使用，就形成了我们所看到的静态页面，这就是所谓的盒模型布局。所以，网页布局的本质，其实就是盒子的摆放问题。 在CSS中，一个完整的盒子由外边距(margin)、边框(border)、内边距(padding)、实际内容(content)4部分组成。 下面的图片说明了盒子模型(Box Model)： Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 那么，这个盒模型的大小是怎么计算的呢？那么一般来说，我们在普通的盒模型中，设置的width实际上是Content的宽度。所以此时，如果一个盒子在内容外还额外添加了内外边距以及边框的时候，那么这个盒子的总宽度则应该是：总元素的宽度 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距（*注：此处填充即指内边距） 也就是说，我们普通盒子的内边距和边框，是会影响到盒子的实际大小的。那么有没有例外的情况呢？答案是有的，下面这就是padding不撑开盒子的情况【注】：当盒子本身没有设置宽度和高度的时候，此时，对盒子设置padding是不会影响到盒子的实际大小的！！！ 关于盒子外边距margin的应用：外边距可以让块级盒子水平居中，但是必须满足两个条件： 盒子必须制定了宽度（width） 盒子左右的外边距都设置为auto即：margin：0 auto 如果想让行内元素或者行内块元素水平居中，只需要给其父亲添加text-align:center即可 外边距合并的问题使用margin定义的块级元素的垂直外边距时，可能会出现外边距的合并。主要有两种情况： 相邻块元素垂直外边距的合并当两个垂直外边距相遇时，他们将形成一个外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。【注意】：只有普通文档流中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并。 解决方案：只给一个元素margin值 嵌套块元素垂直外边距的塌陷对于两个嵌套关系（父子关系）的块元素，父元素有上外边距的同时，子元素也设置了上外边距，此时父元素会他先较大的外边距值。解决方案： 1.可以给父元素定义上边框 2.给父元素定义内边距 3.给父元素添加overflow:hidden 怪异盒和普通盒的区别很明显，在普通盒子模型中，由于种种原因，比如边框和填充会使得盒子撑破，导致我们在网页布局中可能会造成其他元素的错位，或者在完成某些需求的时候需要花费大量精力去计算内外边距边框和内容的占比，进而导致开发效率受限。 所以，在CSS3中，官方为我们带来了一种新的盒子模型，我们称之为IE盒子模型（或者怪异盒子模型），而把之前的普通盒子称作标准盒子模型。 在CSS3中，我们可以通过box-sizing来置顶盒模型类型，即可指定为content-box(标准盒模型)和border-box(IE盒模型)，这样一来，我们计算盒子大小的方式就发生了改变。 标准盒模型content-box：width = content IE盒模型：width = content + paddings + borders","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"HTML5的语义化理解","date":"2019-12-26T06:32:13.000Z","path":"2019/12/26/HTML5的语义化理解/","text":"要解释HTML5的语义化标签，首先我们来看一下什么是Web语义化。 什么是Web语义化Web语义化是指使用恰当的html标签，class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能够快速理解网页内容。语义化的Web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而使得可以让开发人员读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器能够读懂内容。简单来说，就是利于SEO，便于阅读的维护理解。 总结起来就是： 正确的标签做正确的事情 页面内容结构化 即使没有CSS样式的时候，也容易阅读，便于理解和维护 便于浏览器，搜索引擎解析。利于爬虫标记、利于SEO HTML语义化标签HTML为网页文档内容提供了上下文结构和含义。对于HTML体系而言，Web语义化就是指使用恰当的标签，使页面有良好的结构，让页面元素有含义，其中的标签应该都是语义化的定义了文档的结构。 1234567891011121314151617181920212223&lt;html&gt; &lt;body&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;h1 - WEB 语义化&lt;/h1&gt; &lt;/header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;nav1 - HTML语义化&lt;/li&gt; &lt;li&gt;nav2 - CSS语义化&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;section&gt; section1 - HTML语义化 &lt;/section&gt; &lt;section&gt; section2 - CSS语义化 &lt;/section&gt; &lt;time datetime=&quot;2018-03-23&quot; pubdate&gt;time - 2018年03月23日&lt;/time&gt; &lt;footer&gt; footer - by 小维&lt;/footer&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; HTML语义化标签包括body/article/nav/aside/section/header/footer/hgroup,还有h1-h6/address等 下面我们来简单看一下常用的HTML语义化标签 header元素header代表“网页”或者“section”的页眉，通常包含h1-h6 元素或者 hgroup, 作为整个页面或者一个内容快的标题。也可以包裹一节的目录部分，一个搜索框，一个nav，或者相关logo。如下： 123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;h1&gt; &lt;h2&gt;网站副标题&lt;/h2&gt; &lt;/hgroup&gt;&lt;header&gt; 注意事项： 可以是“网页”或者任意“section”的头部部分 没有个数限制 如果hgroup或者h1-h6自己就能工作得很好，那么就没必要用header。 hgroup元素hgroup 元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题组合。如下： 1234&lt;hgroup&gt; &lt;h1&gt;这是一个主标题&lt;/h1&gt; &lt;h2&gt;这是一个副标题&lt;/h2&gt;&lt;/hgroup&gt; 注意事项： 如果只需要一个h1-h6标签就不用hgroup 如果有连续多个h1-h6标签就用hgroup 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签 footer元素footer元素代表“网页”或任意“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果footer元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。如下： 123&lt;footer&gt; COPYRGHT@CheungKH&lt;/footer&gt; 注意事项： 可以是“网页”或者任意“section”的底部部分 没有个数限制，除了包裹的内容不一样，其他跟header类似 nav元素nav 元素代表页面的导航链接区域。用于定义页面的主要导航部分。 代码示例： 123456&lt;nav&gt; &lt;ul&gt; &lt;li&gt;HTML语义化&lt;/li&gt; &lt;li&gt;CSS 语义化&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 侧边栏上目录、面包屑导航、搜索样式、或者下一篇上一篇文章我们可能会想要用到nav，但是事实上规范上说nav只能用在页面主要导航部分上。页脚区域中的链接列表，虽然指向不同网站的不同区域，譬如服务条款，版权页等，这些footer元素就能够用了。 注意事项： 用于整个页面的主要导航部分，不适合就不要用nav元素了 article元素article 代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。除了它的内容，article会有一个标题(通常会在header里)，一个footer页脚。代码示例： 1234567&lt;article&gt; &lt;h1&gt;你好，我是这边文章的标题&lt;/h1&gt; &lt;p&gt;你好，我是文章的内容&lt;/p&gt; &lt;footer&gt; &lt;p&gt;最终解释权归XXX所有&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt; 下面这是一个最简单的例子，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论： 123456789101112131415161718192021222324&lt;article&gt; &lt;header&gt; &lt;h1&gt;web 语义化&lt;/h1&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2018-03-23&quot;&gt;2018-03-23&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;文章内容..&lt;/p&gt; &lt;article&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: 专业水军&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2018-03-23T15:10-08:00&quot;&gt;~1 min ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;还行&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: 大水怪&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2018-03-23T15:10-08:00&quot;&gt;~1 hour ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;楼上说的对&lt;/p&gt; &lt;/article&gt; &lt;/article&gt;&lt;/article&gt; article 内部可以嵌套article，表示评论或者其他跟文章有关联的内容。article内部还可以嵌套section，如下： 123456789101112&lt;article&gt; &lt;h1&gt;web语义化&lt;/h1&gt; &lt;p&gt;什么是语义化？&lt;/p&gt; &lt;section&gt; &lt;h2&gt;语义化详解&lt;/h2&gt; &lt;p&gt;语义化就是。。。&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;语义化特点&lt;/h2&gt; &lt;p&gt;语义化特点就是。。。&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 文章内section是独立的部分，但是它们只能算是组成整体的一部分，从属关系，article是大主体，section是构成这个大主体的一个部分。 注意事项： 自身独立情况下：用article 是相关内容： 用section 没有语义的： 用div section元素section 元素代表文档中的“节”或“段”，“段”可以是指一片文章里按照主题的分段；“节”可以是指一个页面里的分组。section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。代码示例： 1234567891011&lt;section&gt; &lt;h1&gt;section是啥？&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h2&gt; &lt;p&gt;section的介绍&lt;/p&gt; &lt;section&gt; &lt;h3&gt;关于其他&lt;/h3&gt; &lt;p&gt;关于其他section的介绍&lt;/p&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt; 注意事项： 一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。 表示文档中的节或者段。 acticle、nav、aside可以理解为特殊的section，如果可以用article、nav、aside就不要用section，没有实际意义的就用div aside元素aside 元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料，标签，名词解释等。在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。代码示例： 1234567&lt;article&gt; &lt;p&gt;内容&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;CheungKh...&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; 注意事项： aside 在 article 内表示主要内容的附属信息。 在article之外侧可以做侧边栏，没有article与之对应，最好不用 如果是广告，其他日志链接或者其他分类导航也可以用。 HTML语义化小结总之，HTML语义化是反对大篇幅使用无语义化的div+span+class，而鼓励使用HTML定义好的语义化标签。 当然，如果需要兼容低版本的IE浏览器，比如说IE8以及以下，那就需要考虑一些HTML5标签兼容性解决方案了。","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"https://cheungkooho.github.io/tags/HTML/"}]},{"title":"div+CSS布局中常用标签和属性","date":"2019-11-25T12:06:43.000Z","path":"2019/11/25/div+CSS布局中常用标签和属性/","text":"下面这些是div+CSS进行布局时常用的标签和属性 页面布局常用标签无意义块状元素标签 div无意义行内元素标签 span段落标签 p无序列表 ul列表项 li超链接列表 a图片标签 img斜体标签 i粗体标签 b 页面布局常用选择器id选择器 #id类选择器 .class关系选择器 div p\\div&gt;p\\div,p伪类选择器 :hover结构性味蕾选择器 E:after\\E:before\\E:nth-child()\\E:first-child\\E:last-child 页面布局常用基本属性字体属性： font-sise文本属性： text-decoration\\text-align首行缩进： text-indent行高： line-height宽高属性： width\\height\\min-height\\max-height背景属性： background列表属性： list-style字体颜色： color 页面布局常用应用属性定位属性： position布局属性： display *浮动属性： float\\clear盒子模型： border\\margin\\padding圆角边框： border-radius阴影： text-shadow\\box-shadow","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"CSS各种居中方法","date":"2019-11-25T05:06:43.000Z","path":"2019/11/25/CSS各种居中方法/","text":"CSS布局中常用的各种居中方法 一、水平居中1、文本/行内元素/行内块级元素原理：text-align只控制行内内容(文字、行内元素、行内块级元素)如何相对他的块父元素对齐 123#parent&#123; text-align: center;&#125; 优缺点·优点：简单快捷，容易理解，兼容性非常好·缺点：只对行内内容有效；属性会继承影响到后代行内内容；如果子元素宽度大于父元素宽度则无效，只有后代行内内容中宽度小于设置text-align属性的元素宽度的时候，才会水平居中 2、单个块级元素原理：根据规范，有这么一种情况：在margin有节余的同时如果左右margin设置了auto，将会均分剩余空间。另外，如果上下的margin设置了auto，其计算值为0 1234#son&#123; width: 100px; /*必须定宽*/ margin: 0 auto;&#125; 优缺点·优点：简单；兼容性好·缺点：必须定宽，并且值不能为auto；宽度要小于父元素，否则无效 3、多个块级元素原理：text-align只控制行内内容(文字、行内元素、行内块级元素)，如何相对他的块父元素对齐 123456#parent&#123; text-align: center;&#125;.son&#123; display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/&#125; 优缺点·优点：简单，容易理解，兼容性非常好·缺点：只对行内内容有效；属性会继承影响到后代行内内容；块级改为inline-block，换行、空格会产生元素间隔 4、使用绝对定位实现原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的 1234567891011121314#parent&#123; height: 200px; width: 200px; /*定宽*/ position: relative; /*父相*/ background-color: #f00;&#125;#son&#123; position: absolute; /*子绝*/ left: 50%; /*父元素宽度一半,这里等同于left:100px*/ transform: translateX(-50%); /*自身宽度一半,等同于margin-left: -50px;*/ width: 100px; /*定宽*/ height: 100px; background-color: #00ff00;&#125; 优缺点·优点：使用margin-left兼容性好；不管是块级还是行内元素都可以实现·缺点：代码较多；脱离文档流；使用margin-left需要知道宽度值；使用transform兼容性不好（ie9+） 5、任意个元素(flex)原理：就是设置当前主轴对齐方式为居中。说不上为什么，flex无非就是主轴侧轴是重点，然后就是排列方式的设置 1234#parent&#123; display: flex; justify-content: center;&#125; 优缺点·优点：功能强大；简单方便；容易理解·缺点：PC端兼容性不好，移动端（Android4.0+） 本章小结·对于水平居中，我们应该先考虑，哪些元素有自带的居中效果，最先想到的应该就是 text-align:center 了，但是这个只对行内内容有效，所以我们要使用 text-align:center 就必须将子元素设置为 display: inline; 或者 display: inline-block; ；·其次就是考虑能不能用margin: 0 auto; ，因为这都是一两句代码能搞定的事，实在不行就是用绝对定位去实现了。·移动端能用flex就用flex，简单方便，灵活并且功能强大，无愧为网页布局的一大利器 二、垂直居中1、单行文本/行内元素/块级行内元素原理：line-height的最终表现是通过inline box实现的，而无论inline box所占据的高度是多少（无论比文字大还是比文字小），其占据的空间都是与文字内容公用水平中垂线的。 1234#parent&#123; height: 150px; line-height: 150px; /*与height等值*/&#125; 优缺点·优点：简单；兼容性好·缺点：只能用于单行行内内容；要知道高度的值 2、多行文本/行内元素/行内块级元素原理同上 1234#parent&#123; /*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/ height: 150px; line-height: 30px; /*元素在页面呈现为5行,则line-height的值为height/5*/&#125; 优缺点·优点：简单；兼容性好·缺点：只能用于行内内容；需要知道高度和最终呈现多少行来计算出line-height的值，建议用span包裹多行文本 3、图片原理：vertical-align和line-height的基友关系 123456#parent&#123; height: 150px; line-height: 150px; font-size: 0;&#125;img #son&#123;vertical-align: middle;&#125; /*默认是基线对齐，改为middle*/ 优缺点·优点：简单；兼容性好·缺点：需要添加font-size: 0; 才可以完全的垂直居中；不过需要主要，html#parent包裹img之间需要有换行或空格 4、单个块级元素HTML 123&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 4.1、使用tabel-cell实现原理：CSS Table，使表格内容对齐方式为middle 1234#parent&#123; display: table-cell; vertical-align: middle;&#125; 优缺点·优点：简单；宽高不定；兼容性好（ie8+）·缺点：设置tabl-cell的元素，宽度和高度的值设置百分比无效，需要给它的父元素设置display: table; 才生效；table-cell不感知margin，在父元素上设置table-row等属性，也会使其不感知height；设置float或position会对默认布局造成破坏，可以考虑为之增加一个父div定义float等属性；内容溢出时会自动撑开父元素 4.2、使用绝对定位12345678910111213141516171819202122232425262728293031/*原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的*/#parent&#123; height: 150px; position: relative; /*父相*/&#125;#son&#123; position: absolute; /*子绝*/ top: 50%; /*父元素高度一半,这里等同于top:75px;*/ transform: translateY(-50%); /*自身高度一半,这里等同于margin-top:-25px;*/ height: 50px;&#125;/*优缺点- 优点：使用margin-top兼容性好；不管是块级还是行内元素都可以实现- 缺点：代码较多；脱离文档流；使用margin-top需要知道高度值；使用transform兼容性不好（ie9+）*/或/*原理：当top、bottom为0时,margin-top&amp;bottom会无限延伸占满空间并且平分*/#parent&#123;position: relative;&#125;#son&#123; position: absolute; margin: auto 0; top: 0; bottom: 0; height: 50px;&#125;/*优缺点- 优点：简单;兼容性较好(ie8+)- 缺点：脱离文档流*/ 4.3、使用flex实现原理：flex设置对齐方式罢了 1234567891011121314#parent&#123; display: flex; align-items: center;&#125;或#parent&#123;display: flex;&#125;#son&#123;align-self: center;&#125;或/*原理：这个尚未搞清楚，应该是flex使margin上下边界无限延伸至剩余空间并平分了*/#parent&#123;display: flex;&#125;#son&#123;margin: auto 0;&#125; 优缺点·优点：简单灵活；功能强大·缺点：PC端兼容性不好，移动端（Android4.0+） 5、任意个元素原理：flex设置对齐方式 123456789101112131415161718192021#parent&#123; display: flex; align-items: center;&#125;或#parent&#123; display: flex;&#125;.son&#123; align-self: center;&#125;或 #parent&#123; display: flex; flex-direction: column; justify-content: center;&#125; 优缺点·优点：简单灵活；功能强大·缺点：PC端兼容性不好，移动端（Android4.0+） 本章小结·对于垂直居中，最先想到的应该就是 line-height 了，但是这个只能用于行内内容；·其次就是考虑能不能用vertical-align: middle; ，不过这个一定要熟知原理才能用得顺手，建议看下vertical-align和line-height的基友关系 ；·然后便是绝对定位，虽然代码多了点，但是胜在适用于不同情况；·移动端兼容性允许的情况下能用flex就用flex 水平垂直居中1、行内元素/行内块级元素/图片原理：text-align: center; 控制行内内容相对于块父元素水平居中,然后就是line-height和vertical-align的基友关系使其垂直居中，font-size: 0; 是为了消除近似居中的bug 12345678910#parent&#123; height: 150px; line-height: 150px; /*行高的值与height相等*/ text-align: center; font-size: 0; /*消除幽灵空白节点的bug*/&#125;#son&#123; /*display: inline-block;*/ /*如果是块级元素需改为行内或行内块级才生效*/ vertical-align: middle;&#125; 优缺点·优点：代码简单；兼容性好（ie8+）·缺点：只对行内内容有效；需要添加font-size: 0; 才可以完全的垂直居中；不过需要注意html中#parent包裹#son之间需要有换行或空格；熟悉line-height和vertical-align的基友关系较难 2、table-cell原理：CSS Table，使表格内容垂直对齐方式为middle,然后根据是行内内容还是块级内容采取不同的方式达到水平居中 123456789101112#parent&#123; height: 150px; width: 200px; display: table-cell; vertical-align: middle; /*text-align: center;*/ /*如果是行内元素就添加这个*/&#125;#son&#123; /*margin: 0 auto;*/ /*如果是块级元素就添加这个*/ width: 100px; height: 50px;&#125; 优缺点·优点：简单；适用于宽度高度未知情况；兼容性好（ie8+）·缺点：设置tabl-cell的元素，宽度和高度的值设置百分比无效，需要给它的父元素设置display: table; 才生效；table-cell不感知margin，在父元素上设置table-row等属性，也会使其不感知height；设置float或position会对默认布局造成破坏，可以考虑为之增加一个父div定义float等属性；内容溢出时会自动撑开父元素 3、button作为父元素原理：button的默认样式，再把需要居中的元素表现形式改为行内或行内块级就好 123456789button#parent&#123; /*改掉button默认样式就好了,不需要居中处理*/ height: 150px; width: 200px; outline: none; border: none;&#125;#son&#123; display: inline-block; /*button自带text-align: center,改为行内水平居中生效*/&#125; 优缺点·优点：简单方便，充分利用默认样式·缺点：只适用于行内内容；需要清除部分默认样式；水平垂直居中兼容性很好，但是ie下点击会有凹陷效果！ 4、绝对定位原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到几何上的水平垂直居中 12345678910#parent&#123; position: relative;&#125;#son&#123; position: absolute; top: 50%; left: 50%; /*定宽高时等同于margin-left:负自身宽度一半;margin-top:负自身高度一半;*/ transform: translate(-50%,-50%); &#125; 优缺点·优点：使用margin兼容性好；不管是块级还是行内元素都可以实现·缺点：代码较多；脱离文档流；使用margin需要知道宽高；使用transform兼容性不好（ie9+） 5、绝对居中原理：当top、bottom为0时,margin-top&amp;bottom设置auto的话会无限延伸占满空间并且平分；当left、right为0时,margin-left&amp;right设置auto的话会无限延伸占满空间并且平分 12345678910111213#parent&#123; position: relative;&#125;#son&#123; position: absolute; margin: auto; width: 100px; height: 50px; top: 0; bottom: 0; left: 0; right: 0;&#125; 优缺点·优点：无需关注宽高；兼容性较好(ie8+)·缺点：代码较多；脱离文档流 6、flex原理：flex设置对齐方式 123456789101112131415161718192021222324#parent&#123; display: flex;&#125;#son&#123; margin: auto;&#125;或#parent&#123; display: flex; justify-content: center; align-items: center;&#125;或#parent&#123; display: flex; justify-content: center;&#125;#son&#123; align-self: center;&#125; 优缺点·优点：简单灵活；功能强大·缺点：PC端兼容性不好，移动端（Android4.0+） 7、视窗居中原理：vh为视口单位，视口即文档可视的部分，50vh就是视口高度的50/100，设置50vh上边距再 12345#son&#123; /*0如果去掉，则会多出滚动条并且上下都是50vh的margin。如果去掉就给body加上overflow:hidden;*/ margin: 50vh auto 0; transform: translateY(-50%);&#125; 优缺点·优点：简单；容易理解；两句代码达到屏幕水平垂直居中·缺点：兼容性不好（ie9+，Android4.4+） 本章小结·一般情况下，水平垂直居中，我们最常用的就是绝对定位加负边距了，缺点就是需要知道宽高，使用transform倒是可以不需要，但是兼容性不好（ie9+）；·其次就是绝对居中，绝对定位设置top、left、right、bottom为0，然后margin:auto; 让浏览器自动平分边距以达到水平垂直居中的目的；·如果是行内/行内块级/图片这些内容，可以优先考虑line-height和vertical-align 结合使用，不要忘了还有text-align ，这个方法代码其实不多，就是理解原理有点困难，想要熟练应对各种情况还需好好研究；·移动端兼容性允许的情况下能用flex就用flex。","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"CSS浮动清除","date":"2019-11-21T13:06:43.000Z","path":"2019/11/21/CSS浮动清除/","text":"什么是CSS清除浮动？在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 引用W3C的例子，news容器没有包围浮动的元素。 1234567891011121314151617.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;; 清除浮动方法方法一：使用带clear属性的空元素在浮动元素后使用一个空元素如，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用或来进行清理。 12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.clear &#123; clear: both; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 优点：简单，代码少，浏览器兼容性好。缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。 方法二：使用CSS的overflow属性给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 12345678910111213141516171819.news &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 方法三：给浮动的元素的容器添加浮动给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 方法四：使用邻接元素处理什么都不做，给浮动元素后面的元素添加clear属性。 12345678910111213141516171819202122.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.content&#123; clear:both; &#125;&lt;div class=&quot;news&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;div class=&quot;content&quot;&gt;***&lt;/div&gt;&lt;/div&gt; 注意这里的div.content有内容。 方法五：使用CSS的:after伪元素结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 123456789101112131415161718192021222324252627282930.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; float: right; &#125;.clearfix:after&#123; content: &quot;020&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123; /* 触发 hasLayout */ zoom: 1; &#125;&lt;div class=&quot;news clearfix&quot;&gt;&lt;img src=&quot;news-pic.jpg&quot; /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。 总结通过上面的例子，我们不难发现清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。 在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。 最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cheungkooho.github.io/tags/CSS/"}]},{"title":"web网页版简易音乐播放器实现","date":"2019-11-18T13:20:42.000Z","path":"2019/11/18/web网页版简易音乐播放器实现/","text":"下面我们做一个网页版简易音乐播放器Lat’s do it! HTML代码12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;音乐播放器&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;音乐播放器&lt;/header&gt; &lt;section&gt; &lt;ul&gt; &lt;li&gt;Here We Are Again&lt;/li&gt; &lt;li&gt;不谓侠&lt;/li&gt; &lt;li&gt;多想在平庸的生活拥抱你&lt;/li&gt; &lt;li&gt;浪子回头&lt;/li&gt; &lt;li&gt;那个女孩&lt;/li&gt; &lt;li&gt;那女孩对我说&lt;/li&gt; &lt;li&gt;平胸女子&lt;/li&gt; &lt;li&gt;情深深雨濛濛&lt;/li&gt; &lt;li&gt;雅俗共赏&lt;/li&gt; &lt;li&gt;野狼disco&lt;/li&gt; &lt;li&gt;这一生关于你的风景&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;audio src=&quot;&quot; id=&quot;ado&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; &lt;footer&gt; 当前播放的是：&lt;span id=&quot;con&quot;&gt;&lt;/span&gt; &lt;/footer&gt; &lt;/body&gt; &lt;script src=&quot;js/index.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/html&gt; 添加CSS样式123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 写样式通常首先-清空所有标签的内外边距 */*&#123; margin: 0; padding: 0;&#125;/* */body&#123; width: 31.25rem; overflow: auto; /* overflow 属性规定当内容溢出元素框时发生的事情 */ margin: 20px auto; /* 外边距 上下20 水平居中 */&#125;/* 设置头部和底部样式 */header,footer&#123; height: 40px; line-height: 40px; /* 与模块同高 可以字体上下居中显示 */ background: #808080; text-align: center; /* 文本居中 */&#125;/* 给音乐列表写样式 */li&#123; height: 50px; line-height: 50px; border: 1px solid red; /* 添加边框属性 */ border-top: none; /* 上下线条重合 so清空上线条 */ font-size: 15px; /* 字体大小设置 */ text-indent: 20px; /* text-indent 属性规定文本块中首行文本的缩进。 */ /* 注释：允许使用负值。如果使用负值，那么首行会被缩进到左边 */ list-style: none; /* 清空一下列表的样式-列表前方的点或数字 */&#125;/* 音频文件的样式设置 */#ado&#123; width: 100%; height: 20px; margin-top: 10px;&#125;/* 设置控制列表的类名样式 */.sty&#123; background: #FF0000;&#125; JAVAScript代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 通过js实现音乐的播放 --&gt;var lis = document.getElementsByTagName(&apos;li&apos;); //获取dom元素var ado = document.getElementById(&apos;ado&apos;);var con = document.getElementById(&apos;con&apos;);//创建数组存放音乐文件路径，通过下标找到相应文件var arr = [ &apos;audio/Here We Are Again.mp3&apos;, &apos;audio/不谓侠.mp3&apos;, &apos;audio/多想在平庸的生活拥抱你.mp3&apos;, &apos;audio/浪子回头.mp3&apos;, &apos;audio/那个女孩.mp3&apos;, &apos;audio/那女孩对我说.mp3&apos;, &apos;audio/平胸女子.mp3&apos;, &apos;audio/情深深雨濛濛.mp3&apos;, &apos;audio/雅俗共赏.mp3&apos;, &apos;audio/野狼disco.mp3&apos;, &apos;audio/这一生关于你的风景.mp3&apos;]//通过循环遍历的方式添加点击事件for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function()&#123; for (var i = 0; i &lt; lis.length; i++) &#123; if (this === lis[i]) &#123; lis[i].className = &apos;sty&apos;; ado.src = arr[i]; ado.play(); con.innerHTML = lis[i].innerHTML; var a = i; //通过ended事件监听是否播放完毕 ado.onended = function()&#123; a++; if(a&gt;lis.length-1)&#123; a = 0; &#125; //通过for循环清空所有样式列表 for (var j = 0; j &lt; lis.length; j++) &#123; lis[j].className = &apos;&apos;; &#125; //通过下标a给相应的列表进行样式的修饰和音乐的播放 con.innerHTML = lis[a].innerHTML; ado.src = arr[a]; ado.play(); lis[a].className = &apos;sty&apos;; &#125; &#125; else&#123; lis[i].className = &apos;&apos;; &#125; &#125; &#125;&#125; 完成效果 注释把音乐文件放进相应的目录下即可。","comments":true,"tags":[{"name":"小玩意儿","slug":"小玩意儿","permalink":"https://cheungkooho.github.io/tags/%E5%B0%8F%E7%8E%A9%E6%84%8F%E5%84%BF/"}]},{"title":"HTML基础标签","date":"2019-11-17T12:57:30.000Z","path":"2019/11/17/HTML基础标签/","text":"HTML基础标签 标签 描述 &lt;!DOCTYPE&gt; 定义文档类型。 &lt;html&gt; 定义 HTML 文档。 &lt;title&gt; 定义文档的标题。 &lt;body&gt; 定义文档的主体。 &lt;h1&gt; to &lt;h6&gt; 定义 HTML 标题。 &lt;p&gt; 定义段落。 &lt;br&gt; 定义简单的折行。 &lt;hr&gt; 定义水平线。 &lt;!--...--&gt; 定义注释。 &lt;!DOCTYPE&gt; 标签定义和用法&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 &lt;html&gt; 标签之前。 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。 HTML5 不基于 SGML，所以不需要引用 DTD。 提示：请始终向 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，这样浏览器才能获知文档类型。 HTML 4.01 与 HTML5 之间的差异在 HTML 4.01 中有三种 &lt;!DOCTYPE&gt; 声明。在 HTML5 中只有一种：&lt;!DOCTYPE html&gt; 提示和注释注释：&lt;!DOCTYPE&gt; 声明没有结束标签。提示：&lt;!DOCTYPE&gt; 声明对大小写不敏感。 &lt;html&gt; 标签定义和用法此元素可告知浏览器其自身是一个 HTML 文档。 &lt;html&gt; 与 &lt;/html&gt; 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。 提示和注释注释：即使 html 元素是文档的根元素，它也不包含 doctype 元素。doctype 元素必须位于 html 元素之前。 属性 属性 值 描述 manifest url 定义一个 URL，在这个 URL 上描述了文档的缓存信息。 xmlns 定义 XML namespace 属性。 &lt;title&gt; 标签定义和用法&lt;title&gt; 元素可定义文档的标题。 浏览器会以特殊的方式来使用标题，并且通常把它放置在浏览器窗口的标题栏或状态栏上。同样，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。 提示和注释提示：&lt;title&gt; 标签是 &lt;head&gt; 标签中唯一要求包含的东西。 标准属性&lt;title&gt; 标签支持以下标准属性： 属性 值 描述 dir rtl ltr 规定元素中内容的文本方向。 lang language_code 规定元素中内容的语言代码。 xml:lang language_code 规定 XHTML 文档中元素内容的语言代码。 &lt;body&gt; 标签定义和用法body 元素定义文档的主体。 body 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） HTML 与 XHTML 之间的差异在 HTML 4.01 中，所有 body 元素的“呈现属性”均不被赞成使用。 在 XHTML 1.0 Strict DTD 中，所有 body 元素的“呈现属性”均不被支持。 可选的属性 属性 值 描述 alink rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。 规定文档中活动链接（active link）的的颜色。 background URL 不赞成使用。请使用样式取代它。 bgcolor rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。 规定文档的背景颜色。 link rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。 规定文档中未访问链接的默认颜色。 text rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。 规定文档中所有文本的颜色。 vlink rgb(x,x,x)#xxxxxxcolorname 不赞成使用。请使用样式取代它。规定文档中已被访问链接的颜色。 &lt;h1&gt; 到 &lt;h6&gt; 标签定义和用法&lt;h1&gt; - &lt;h6&gt; 标签可定义标题。&lt;h1&gt; 定义最大的标题。&lt;h6&gt; 定义最小的标题。 由于 h 元素拥有确切的语义，因此请您慎重地选择恰当的标签层级来构建文档的结构。因此，请不要利用标题标签来改变同一行中的字体大小。相反，我们应当使用层叠样式表定义来达到漂亮的显示效果。 标准属性 id, class, title, style, dir, lang, xml:lang 事件属性 onclick, ondblclick, onmousedown, onmouseup, onmouseover,onmousemove, onmouseout, onkeypress, onkeydown, onkeyup &lt;p&gt; 标签定义和用法&lt;p&gt; 标签定义段落。 p 元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，您也可以在样式表中规定。 &lt;br&gt; 标签定义和用法&lt;br&gt; 可插入一个简单的换行符。 &lt;br&gt; 标签是空标签（意味着它没有结束标签，因此这是错误的：&lt;br&gt;&lt;/br&gt;）。在 XHTML 中，把结束标签放在开始标签中，也就是 &lt;br /&gt;。 请注意，&lt;br&gt; 标签只是简单地开始新的一行，而当浏览器遇到 &lt;p&gt; 标签时，通常会在相邻的段落之间插入一些垂直的间距。 clear 属性如果您希望文本流在内联表格或图像的下一行继续输出，请使用 clear 属性，该属性有三个可选的值：left、right 或者 all，每个值都代表一个边界或两边的边界。 提示和注释注释：请使用 &lt;br&gt; 来输入空行，而不是分割段落。 &lt;hr&gt; 标签定义和用法&lt;hr&gt; 标签在 HTML 页面中创建一条水平线。 水平分隔线（horizontal rule）可以在视觉上将文档分隔成各个部分。 可选的属性 属性 值 描述 align centerleftright 不赞成使用。请使用样式取代它。 规定 hr 元素的对齐方式。 noshade noshade 不赞成使用。请使用样式取代它。规定 hr 元素的颜色呈现为纯色。 size pixels 不赞成使用。请使用样式取代它。规定 hr 元素的高度（厚度）。 width pixels% 不赞成使用。请使用样式取代它。规定 hr 元素的宽度。 &lt;!--...--&gt;标签定义和用法注释标签用于在源代码中插入注释。注释不会显示在浏览器中。 您可使用注释对您的代码进行解释，这样做有助于您在以后的时间对代码的编辑。当您编写了大量代码时尤其有用。 使用注释标签来隐藏浏览器不支持的脚本也是一个好习惯（这样就不会把脚本显示为纯文本）。","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"https://cheungkooho.github.io/tags/HTML/"}]},{"title":"Markdown语法的简要规则","date":"2019-11-15T16:33:07.000Z","path":"2019/11/16/Markdown语法的简要规则/","text":"Markdown简介 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书。 标题标题是每篇文章都需要也是最常用的格式。在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。‘# 一级标题’‘## 二级标题’‘### 三级标题’以此类推，总共六级标题。建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号，要和文字之间加上一个字符的空格。 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。 例如这样 只需要在文本前加入 &gt; 这种尖括号（大于号）即可 图片与链接插入链接与插入图片的语法很像，区别在一个 !号图片为：![]()链接为：[]() 插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 例如：这里是粗体 这里是斜体 表格表格是我觉得 Markdown 比较累人的地方，例子如下： | Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 这种语法生成的表格如下： 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例： 使用 tab 键即可缩进。 分割线分割线的语法只需要三个 * 号或者三个-，例如： ***--- 到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。","comments":true,"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://cheungkooho.github.io/tags/Markdown/"}]},{"title":"Hello World","date":"2019-11-15T09:30:29.139Z","path":"2019/11/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]